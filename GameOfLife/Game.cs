using System.IO.Pipes;
using System.Net.Mail;
using System.Security.Cryptography.X509Certificates;

namespace GameOfLife
{
    /* Реализуйте игру в жизнь на прямоугольном конечном поле.
     
     На каждом ходе клетка меняет свое состояние по таким правилам:
     1. Если у нее менее 2 живых соседей или более трех живых — она становится мертвой (false).
     2. Если ровно 3 живых соседа, то клетка становится живой (true)
     3. Если ровно 2 живых соседа, то клетка сохраняет своё состояние.

     У каждой неграничной клетки есть 8 соседей (в том числе по диагонали)

    Работу над игрой постройте итеративно в стиле TDD:
        1. Сначала напишите какой-нибудь простейший тест в соседнем файле GameTest.cs. Тест должен быть красным.
        То есть должен проверять ещё нереализованное требование.
        2. Только потом напшишите простейшую реализацию, которая делает тест зеленым. 
        Не старайтесь реализовать всю логику, просто сделайте тест зеленым как можно быстрее.
        3. Повторяйте процесс, пока ещё можете придумать новые красные тесты.

     На каждый шаг (тест и реализация) у вас должно уходить не более 5 минут.
     Если вы не успели поднять тест за 5 минут — удалите этот тест и придумайте тест попроще.
     Засекайте время таймером на телефоне.

     После каждого шага (тест или реализация) меняйте активного человека за клавиатурой.

     Начните с простейших тестов. 

     Проект настроен так, что при каждой сборке запускаются все тесты и отчет выводится на консоль
    */
    public class Game
    {
        public static int CountNeighbors(int i, int j, bool[,] field)
        {
            var dx = new [] {0, 0, 1, 1, 1, -1, -1, -1};
            var dy = new [] {1, -1, 0, 1, -1, 0, 1, -1};
            var answer = 0;
            for (int k = 0; k < 8; k++)
            {
                if (i + dx[k] < field.Length && 0 <= i + dx[k] && j + dy[k] < field.Length && 0 <= j + dy[k] && field[i + dx[k], j + dy[k]])
                {
                    answer++;   
                }
            }
            return answer;
        }
        public static bool[,] NextStep(bool[,] field)
        {
            var newField = new bool[field.Length, field.Length];
            for (int i = 0; i < field.Length; i++)
            {
                for (int j = 0; j < field.Length; j++)
                {
                    int countNeighbors = CountNeighbors(i, j, field);
                    if (countNeighbors == 3)
                    {
                        newField[i, j] = true;
                    }
                    else if (countNeighbors == 2)
                    {
                        newField[i, j] = field[i, j];
                    }
                    else
                    {
                        newField[i, j] = false;
                    }
                }
            }
            return newField;
        }
    }
}